\section{Exemples de programmes Prolog}

Maintenant que nous avons vu l'algorithm d'exécution de Prolog,
regardons quelques programmes pour voir comment on peut programmer en Prolog.
L'idée de base est qu'un programme est un ensemble d'axiomes qui énoncent des propriétés vraies
des algorithmes que l'on veut programmer, tout en permettant l'exécution de procéder de façon efficace.
La programmation de Prolog est donc l'art de faire une spécification logique qui possède une exécution efficace.
L'invention de Prolog a donc donné naissance à un style de programmation nouveau.
Dans cette section nous ne pouvons montrer qu'une toute petite partie de ce style,
mais vous êtes encouragés à explorer d'autres programmes en Prolog et à télécharger
un des nombreux systèmes Prolog pour les exécuter.

\subsection{Exemple 1: Factorielle}

\subsubsection{Programme (code Prolog)}
Ce petit programme permet de calculer la factorielle d'un nombre. Il s'agit de clauses exprimant des faits, des règles et des questions. Le code commence par un fait: 0!==1. Ensuite, il définit une clause pour les factorielles de façon généralisée. Attention, les virgules et les points sont importants. Les virgules sont les séparateurs entre les littéraux dits négatifs tandis que le point marque la fermeture de la clause.
\begin{verbatim}
fact(0,1).
fact(N,F) :- N>0, 
        N1 is N-1,
        fact(N1,F1), 
        F is N* F1 .
\end{verbatim}

\subsubsection{Requête} Nous allons maintenant exécuter le programme fact afin de trouver la factorielle de 5 et stocker la réponse dans la variable F. Le prompt Prolog est représenté par " |?- " et la sortie standard par "->". Les commentaires sont après les "\%" ou entre "/* */". Il ne faut pas oublier le point à la fin de la requête.
\begin{verbatim} 
|?- fact(5,F). % requête
-> F=120 % réponse
\end{verbatim}

\subsubsection{Forme clausale}
Voici le programme réécrit sous forme clausale. 
\begin{align*}
fact(0,1) \\
 \wedge & \\
&( \neg n > 0 \\
&	\vee \neg minus( n1, n, 1) \\
&	\vee \neg fact(n1, f1) \\
&	\vee \neg times(f, n, f1) \\
&	\vee fact(n, f) ) \\
\end{align*}

\subsubsection{Exécution} 
Le but de l'exécution est de prouver que $G \equiv fact(5, r)$. Pour y arriver, Prolog va faire une suite de substitutions $\sigma$ afin de vérifier les affirmations contenues dans r. La substitution finale contiendra le résultat final.

\begin{align*}
& G \equiv fact(5,r) \\
& r= < fact(5, r) > \\
& \% (1) \\
& \sigma = \{ (n, 5), (f, r) \} \\
& r= < ( 5>0 ), minus(n1, 5, 1), fact(n1, f1), times(r, 5, f1) > \sigma \\
& \% (2) \\
& r= < minus(n1, 5, 1), fact(n1, f1), times(r, 5, f1) > \\
& \sigma'= \{ (n1, 4) \cup \sigma\} \\
& r= < fact(4, f1), times(r, 5, f1) > \\
& [...]\\
& \sigma_{res} = \{(r,120),...\} 
\end{align*}
(1) avec clause 2\\
(2) a>b existe dans le système prédéfini -> true\\

\subsection{Exemple 2: Append de deux listes}

Le but de cet exemple est de faire un "append" de deux listes:\\
append([1], [2], L)

\paragraph{Prolog:}
\begin{itemize}
\item append ( [] , L , L)
\item append ([X|L1], L2, [X|L3]) :- append (L1,L2,L3)
\end{itemize}
\paragraph{Clausal}
Le programme réécrit sous forme clausale.\\
append(nil,l',l')\\
$\land$\\
($\neg$append($l_1,l_2,l_3$) $\land$ append (cons(x, $l_1$), $l_2$, cons(x,$l_3$))
\paragraph{Execution}
Attention, l'exécution du programme est une preuve en soi.\\
G = append (cons(1,nil), cons(2, nil), l)
\begin{itemize}
\item[1.] 
		$r$= < append (cons(1,nil), cons(2,nil, l)> et
		$\sigma_1$ = {(x,1), ($l_1$,nil), ($l_2$, cons(2,nil)), (cons(x,$l_3$),l)}
\item[2.]
		r=< append(nil,cons(2,nil),$l_3$)> et
		$\sigma_2$ = { (l', cons(2, nil), ($l_3$,l') }
		
\item[3.]
		r=<>
		
\item[Résultat]
l = con (1, $l_3$)
$l_3$ = l'
l' = cons(2,nil)
l=con(1,cons(1,nil))


\end{itemize}

\subsection{Exemple 3: Append avec plusieurs solutions}

Intéressons-nous à la manière dont prolog exécute la requête \textbf{|?- append (L1,L2,[1])} en nous basant sur la syntaxe définie lors de l'exemple 2.\\
Pour information, la fonction cons prend comme premier argument une valeur et comme second argument une liste. Elle place le premier argument en tête du second argument.\\

\paragraph{Requête}
\begin{verbatim} 
|?- append (L_{1},L_{2},[1]). %requête
-> r = <append (l_{1}',l_{2}',cons(1,nil))> % réponse

		L_{1} = [],
		L_{2} = [1]. %clause 1
ou		
		L_{1} = [1],
		L_{2} = []. %clause 2
\end{verbatim}

\paragraph{Forme clausale}
Le programme réécrit sous forme clausale.\\
append(nil,l',l')\\
$\land$\\
($\neg$append($l_{1},l_{2},l_{3}$)
$\vee$ append (cons(x, $l_{1}$), $l_{2}$, cons(x,$l_{3}$))

\paragraph{Exécution}
Dans cet exemple, il y a plusieurs chemins pour arriver au résultat
\begin{itemize}
\item[] Si l'on choisit la clause 1: 
\begin{align*}
&\sigma = {(l_{1}',nil), (l_{2}',l'), (l',cons(1,nil))} \\
&r= < > \\
& l_{1}'=nil \\
& l_{2}'=cons(1,nil) \\
\end{align*}

\item[] Si l'on choisit la clause 2: 
\begin{align*}
&\sigma = {(l_{1}',cons(x,l_{1})), (l_{2}',l_{2}), (x,1), (l_{3},nil)} \\
&r= < append(l_{1},l_{2}',nil) > \\
&\sigma = {(l_{1},nil), (l_{2},l_{2}'), (nil,l_{3})} \\
&r= < > \\
& l_{1}'=nil \\
& l_{2}'=cons(1,nil) \\
\end{align*}

\end{itemize}


Il existe deux manières de percevoir une exécution Prolog

\begin{itemize}
\item[1] Approche "impérative" : l'exécution est vue comme une séquence de calculs
\item[2] Approche logique : l'exécution est vue comme une preuve. Cette approche n'existe pas dans les langages classiques, c'est ce qui fait la force de Prolog.
\end{itemize}

Prolog est présent dans beaucoup de domaines de programmation :

\begin{itemize}
\item Dans la gestion de base de données avec Datalog
\item Dans la sémantique web
\item Dans la programmation par contrainte. Les substitutions sont remplacées par des relations quelconques.
\end{itemize}

